# 해시

해시함수 - 임의 길이의 데이터를 고정된 길이의 데이터로 대응시키는 함수

해시함수(f)를 이용해 key를 고정된 길이의 정수로 만들면 고정된 크기의 배열에 value를 저장할 수 있게 되며,
이때 탐색(find), 삭제(erase), 추가(insert), 변경(update) 모두 O(1)이 소요된다.

### 충돌 회피
충돌 - 해시함수를 사용할 때 서로 다른 key가 같은 해시 값을 가질 수 있게 되며 이를 충돌이라고 한다.
해시함수를 적절히 선택하여 충돌양을 줄일 수는 있겠지만 이를 없애는 것은 불가능하다고 보는게 맞다.

충돌 회피 방식
1. Chaining
    각 인덱스마다 연결리스트를 두어 충돌을 관리하는 방법
    최악의 경우 모든 키의 해시값이 같을 수도 있으며 이때 탐색, 삭제, 변경에 O(N)이 소요된다.

2. Open Addressing
    데이터의 해시값의 위치에 데이터가 이미 차있는 경우, 다른 칸을 활용하여 충동을 관리하는 방법
    특정 값을 찾을 때 해당값이 존재하지 않는다고 확인하기 위해서 인덱스가 해시값인 위치 부터 비어있는 칸을 찾을 때 가지 탐색해야 한다. -> 최악의 경우를 상정하면 계속해서 반복문이 돌거나, 전체 데이터를 확인해야 할 수 있다. 또한 데이터 삭제가 일어나 저장된 데이터 사이 빈 공간이 발생하는 경우 탐색에 방해가 될 수 있다. 

    * linear probing $$+1$$ : cache hit rate가 높지만, clustering 문제가 발생할 수 있다.
    * quadratic probing $$+i^2$$ : cache hit rate가 준수하고, clustering을 약간 회피할 수 있다.
    * double hashing $$+f'(x)$$: 충돌이 발생할 경우 새로운 해시 함수를 이용해 변경할 위치를 결정하는 방식으로 clustering을 효과적으로 회피할 수 있다. 하지만 cache hit rate은 아주 낮아지게 된다.

# STL을 이용해 해시 구현하기
1. unordered_set : 원소의 중복 허용하지 않음.
2. unordered_multiset : 원소의 중복 허용. !erase(val)로 삭제시 중복된 값을 모두 지우게 됨!
3. unordered_map : key에 대응되는 값을 찾아줌. key의 중복을 허용하지 않음.
4. unordered_multimap